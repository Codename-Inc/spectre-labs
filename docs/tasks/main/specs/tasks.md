# Tasks — `--dry-run` Flag for spectre-build

*Generated by create_tasks on 2026-02-17*

## Objective
Add a `--dry-run` flag that prints the pipeline stages and transitions that would execute, then exits without invoking any agent.

## Scope
- **In Scope**: `--dry-run` argparse flag, pipeline config formatting utility, interception across all execution paths (default pipeline, explicit pipeline YAML, plan pipeline, manifest, resume, legacy build-only), tests
- **Out of Scope**: Changes to pipeline executor, stage behavior, prompt templates, completion strategies, hooks, or agent runners

## Requirements Traced

| ID | Description | Source | Tasks |
|----|-------------|--------|-------|
| REQ-001 | Add `--dry-run` argparse flag | scope.md | 1.1 |
| REQ-002 | When set, print pipeline stages and transitions then exit | scope.md | 1.1, 2.1, 2.2, 2.3 |
| REQ-003 | No actual agent invocations | scope.md | 2.1, 2.2, 2.3 |

---

## Architecture Context

### Where This Fits
- Extends `cli.py` argument parsing and execution routing — the same module that handles `--plan`, `--validate`, `--pipeline`, and manifest/resume modes
- Reads from `PipelineConfig` / `StageConfig` dataclasses (`pipeline/executor.py:50-64`, `pipeline/stage.py:22-40`) which already contain all stage and transition metadata needed for display

### Technical Approach
- Add the flag in `parse_args()` following the `--plan` pattern (`action="store_true"`)
- Create a formatting utility that takes a `PipelineConfig` and prints a human-readable stage/transition summary
- Intercept in each execution path *after* the pipeline config is built but *before* `PipelineExecutor.run()` is called — print and `sys.exit(0)`
- For the legacy path (`run_build_validate_cycle` — no `PipelineConfig`), print a simpler description of the build loop with max iterations

### Key Decisions
- Interception at the routing level (in `main()`, `run_resume()`, `run_manifest()`) keeps changes localized to `cli.py` and avoids touching the executor
- A standalone formatting function decouples presentation from pipeline construction, making it testable in isolation
- Legacy build-only mode gets a simplified message since there is no `PipelineConfig` to inspect

---

## Tasks

### Phase 1: Core Infrastructure

#### [1.1] Add `--dry-run` Flag and Pipeline Formatting Utility
- [ ] **1.1.1** Add `--dry-run` flag to `parse_args()` in `cli.py`
  - **Produces**: `args.dry_run` boolean on parsed Namespace
  - **Consumed by**: `main()`, `run_resume()`, `run_manifest()` routing logic (tasks 2.1–2.2)
  - **Replaces**: N/A (new flag)
  - [ ] Flag registered with `action="store_true"`, help text describes "print pipeline plan without executing"
  - [ ] `args.dry_run` defaults to `False` when flag is absent

- [ ] **1.1.2** Implement `format_pipeline_plan()` utility function in `cli.py`
  - **Produces**: Formatted multi-line string describing pipeline stages, transitions, and end signals
  - **Consumed by**: All dry-run interception points in `main()`, `run_resume()`, `run_manifest()` (tasks 2.1–2.2)
  - **Replaces**: N/A (new function)
  - [ ] Accepts a `PipelineConfig` and returns a formatted string
  - [ ] Output includes pipeline name, each stage in execution order walking from `start_stage` through transitions, transition signals between stages, and end signals that terminate the pipeline
  - [ ] Follows existing print output conventions (emoji prefixes, `=` separator lines consistent with executor output style)

### Phase 2: Route Interception

#### [2.1] Intercept `--plan` and Default Pipeline Routing in `main()`
- [ ] **2.1.1** Add dry-run check in the `--plan` branch of `main()` (after context file validation, before `run_plan_pipeline()`)
  - **Produces**: Plan pipeline summary printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips `run_plan_pipeline()`)
  - [ ] Calls `create_plan_pipeline()` to build the config, passes to `format_pipeline_plan()`, prints result
  - [ ] Exits with code 0 without calling `run_plan_pipeline()` or `save_session()`

- [ ] **2.1.2** Add dry-run check in the `--pipeline` branch of `main()` (after config loading, before `run_pipeline()`)
  - **Produces**: Explicit pipeline summary printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips `run_pipeline()`)
  - [ ] Loads pipeline config via `load_pipeline()`, passes to `format_pipeline_plan()`, prints result
  - [ ] Exits with code 0 without calling `run_pipeline()` or `save_session()`

- [ ] **2.1.3** Add dry-run check in the `--validate` branch of `main()` (after input validation, before `run_default_pipeline()`)
  - **Produces**: Default 3-stage pipeline summary printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips `run_default_pipeline()`)
  - [ ] Calls `create_default_pipeline()` to build the config, passes to `format_pipeline_plan()`, prints result
  - [ ] Exits with code 0 without calling `run_default_pipeline()` or `save_session()`

- [ ] **2.1.4** Add dry-run check in the legacy (no validate, no pipeline) branch of `main()`
  - **Produces**: Simple build loop description printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips `run_build_validate_cycle()`)
  - [ ] Prints a message indicating legacy build-only mode with max iterations count and tasks file path (no `PipelineConfig` to format)
  - [ ] Exits with code 0 without calling `run_build_validate_cycle()` or `save_session()`

#### [2.2] Intercept Resume and Manifest Routing
- [ ] **2.2.1** Add dry-run check in `run_resume()` after loading session and displaying summary, before executing any `run_*` function
  - **Produces**: Pipeline summary for the saved session printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips execution)
  - [ ] `run_resume()` already receives `args` — check `args.dry_run` after session load and summary display
  - [ ] Builds the appropriate pipeline config from saved session state (plan resume → `create_plan_resume_pipeline()`, pipeline YAML → `load_pipeline()`, validate → `create_default_pipeline()`, else legacy message)
  - [ ] Prints formatted pipeline plan and exits with code 0

- [ ] **2.2.2** Add dry-run check in `run_manifest()` after loading and parsing manifest, before executing
  - **Produces**: Pipeline summary for the manifest config printed to stdout, then `sys.exit(0)`
  - **Consumed by**: End user (terminal output)
  - **Replaces**: N/A (early exit, skips execution)
  - [ ] After `load_manifest()` and input validation (so dry-run still validates the manifest), checks `args.dry_run`
  - [ ] Builds the appropriate pipeline config from manifest settings (validate → `create_default_pipeline()`, else legacy message)
  - [ ] Prints formatted pipeline plan and exits with code 0

#### [2.3] Add Tests for `--dry-run`
- [ ] **2.3.1** Add test class for `--dry-run` argument parsing and `format_pipeline_plan()` output
  - **Produces**: pytest test class in `tests/test_dry_run.py` validating flag parsing and formatting
  - **Consumed by**: CI / developer verification
  - **Replaces**: N/A (new test file)
  - [ ] Test that `--dry-run` sets `args.dry_run` to `True` and absence defaults to `False`
  - [ ] Test output includes pipeline name, stage names, and transition signals for default and plan pipeline configs

- [ ] **2.3.2** Add test class for dry-run interception across execution paths
  - **Produces**: pytest tests validating that dry-run prints and exits without agent invocation
  - **Consumed by**: CI / developer verification
  - **Replaces**: N/A (new tests)
  - [ ] Test `--dry-run --validate --tasks tasks.md` prints default pipeline stages and calls `sys.exit(0)` — mock `run_default_pipeline` and assert NOT called
  - [ ] Test `--dry-run --plan --context scope.md` prints plan pipeline stages and calls `sys.exit(0)` — mock `run_plan_pipeline` and assert NOT called
  - [ ] Test `--dry-run --tasks tasks.md` (no validate) prints legacy mode info and calls `sys.exit(0)` — mock `run_build_validate_cycle` and assert NOT called

---

## Execution Strategies

### Sequential Execution
1. 1.1 - Add `--dry-run` Flag and Pipeline Formatting Utility (no dependencies)
2. 2.1 - Intercept `--plan` and Default Pipeline Routing in `main()` (depends on 1.1)
3. 2.2 - Intercept Resume and Manifest Routing (depends on 1.1)
4. 2.3 - Add Tests (depends on 1.1, 2.1, 2.2)

### Parallel Execution

**Wave 1**: 1.1
- Rationale: Foundation — flag parsing and formatting utility must exist before any interception points can use them

**Wave 2 (concurrent)**: 2.1, 2.2
- Rationale: Both interception tasks depend only on Wave 1, not each other — they modify different functions in `cli.py` (`main()` vs `run_resume()`/`run_manifest()`)

**Wave 3**: 2.3
- Rationale: Tests validate all prior work — must run after implementation is complete

---

## Coverage Summary
- Total Requirements Extracted: 3
- Requirements with Task Coverage: 3 (100%)
- Phases: 2
- Parent Tasks: 4
- Sub-tasks: 8
