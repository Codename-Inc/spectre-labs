# Tasks â€” Token-Efficient Build Loop (Phase Owner Pattern)
*Generated by create_tasks on 2026-02-18*

## Objective
Replace per-task fresh-session build model with phase owners that dispatch parallel subagents, reducing input token reads from N (tasks) to P (phases) while gaining speed through wave-based parallelization.

## Scope
- **In Scope**: Build prompt rewrite (phase owner), code review context isolation, pipeline config cleanup, hooks verification, token tracking improvements
- **Out of Scope**: Plan loop optimization, output token reduction, pipeline executor/stage/completion changes, CLI flags, session/resume logic, validate dispatch pattern changes

## Requirements Traced
| ID | Description | Source | Tasks |
|----|-------------|--------|-------|
| REQ-001 | Phase owner reads context once per phase, dispatches subagents | scope.md | 1.1 |
| REQ-002 | Subagents receive only task-specific context from phase owner | scope.md | 1.1 |
| REQ-003 | Wave-based parallel dispatch via Task tool | scope.md | 1.1 |
| REQ-004 | Structured completion reports from subagents | scope.md | 1.1 |
| REQ-005 | Adaptive wave planning (review reports between waves) | scope.md | 1.1 |
| REQ-006 | Independent subagent commits | scope.md | 1.1 |
| REQ-007 | Subagent progress doc writes | scope.md | 1.1 |
| REQ-008 | Code review receives only task descriptions + files, no full docs | scope.md | 2.2 |
| REQ-009 | Enhanced build artifacts (phase_task_descriptions, files_touched) | plan.md | 1.1, 2.2 |
| REQ-010 | Remove TASK_COMPLETE â†’ build loopback, adjust max_iterations | plan.md | 2.1 |
| REQ-011 | Verify hooks and artifact propagation work with new pattern | plan.md | 3.1 |
| REQ-012 | Token tracking from JSONL transcripts for subagent usage | scope.md | 4.1 |

---

## Architecture Context

### Where This Fits
- Modifies the **build stage prompt** (`prompts/build.md`) â€” the instruction template that runs inside `Stage.run_iteration()` via `AgentRunner`
- Updates **code review prompt** (`prompts/code_review.md`) â€” removing full doc reads for intentional isolation
- Adjusts `create_default_pipeline()` in `pipeline/loader.py` â€” transitions and max_iterations
- Existing pipeline orchestration (`executor.py`, `stage.py`, `completion.py`) stays unchanged

### Technical Approach
- **Pattern**: Copy the wave dispatch pattern from `spectre:execute` (`/Dev/spectre/plugins/spectre/commands/execute.md`)
- **Key mechanism**: Phase owner constructs dynamic Task tool prompts with injected context; subagents return completion reports; phase owner aggregates and emits promise tags
- **Artifact flow**: Build artifacts (`phase_task_descriptions`, `files_touched`) flow to code review via `context.update(result.artifacts)` in `executor.py:275` â€” no executor changes needed
- **Git hooks**: Still work because subagent commits are visible in the repo; `after_stage_hook("build")` collects diff as before

### Key Decisions
- Phase owner = one session per phase (not per task) â€” reads context once
- Subagents get dynamic prompts (not template files) â€” matches spectre:execute pattern
- TASK_COMPLETE loopback removed â€” phase owner handles task iteration internally
- Token tracking deferred to Phase 2 â€” ship phase owner pattern first

---

## Tasks

### Phase 1: Phase Owner Build Prompt

#### [x] [1.1] Rewrite build.md as phase owner prompt
- [x] **1.1.1** Design the context gathering section of the phase owner prompt. Agent reads progress file, context files, tasks file, and identifies the current phase (first phase with incomplete `[ ]` parent tasks). Also checks for review fixes and remediation files (same as current prompt Steps 1.4 and 1.5)
  - **Produces**: Phase owner's internal understanding of current state + current phase identification
  - **Consumed by**: Wave planning section (1.1.2) uses phase identification to extract tasks
  - **Replaces**: Current build.md Steps 1-2 (context gathering + task selection)
  - [x] Agent reads all context docs exactly once per session
  - [x] Current phase identified correctly (first phase with incomplete tasks)
  - [x] Review fixes and remediation files handled identically to current behavior

- [x] **1.1.2** Design the wave planning section. Phase owner extracts all parent tasks in the current phase, groups them into parallelizable waves using the task doc's wave/execution structure, and validates that tasks within each wave don't share file scopes
  - **Produces**: Ordered list of waves, each containing task IDs + descriptions + file scope estimates
  - **Consumed by**: Subagent dispatch section (1.1.3) uses waves to construct Task tool calls
  - **Replaces**: Current build.md Step 2 (single task selection â€” now selects entire phase)
  - [x] Tasks grouped into waves matching task doc's execution strategy structure
  - [x] Phase owner validates no file conflicts within a wave before dispatch

- [x] **1.1.3** Design the subagent dispatch section. For each task in a wave, phase owner constructs a Task tool call with: task description (full text), relevant context snippets extracted from docs, build progress file path, and dynamic instructions (TDD via `@skill-spectre:spectre-tdd`, commit format, completion report template). All tasks in a wave dispatched in a single message
  - **Produces**: Parallel Task tool calls dispatching subagents; subagents return completion reports
  - **Consumed by**: Aggregation section (1.1.4) reads completion reports
  - **Replaces**: Current build.md Steps 3-4 (task execution + verification â€” now done by subagents)
  - [x] Dynamic prompt includes task description, context snippets, progress path, and TDD instructions
  - [x] All tasks in wave dispatched simultaneously (single message, multiple Task tool calls)
  - [x] Subagent prompt includes completion report template (files changed, scope signal, discoveries, guidance)
  - [x] Subagent instructed to commit independently with `feat({task_id}): {description}` format

- [x] **1.1.4** Design the aggregation and adaptive planning section. Phase owner reads all completion reports from the wave, reviews scope signals (âšª/ðŸŸ¡/ðŸŸ /ðŸ”´), marks tasks `[x]` in tasks file, adapts remaining waves if signals indicate issues, updates build progress with phase-level summary
  - **Produces**: Updated tasks file, updated progress file, adapted wave plan (if needed)
  - **Consumed by**: Next wave dispatch (loop back to 1.1.3) or completion section (1.1.5)
  - **Replaces**: Current build.md Step 5 (progress update â€” now aggregates from multiple subagents)
  - [x] Scope signals reviewed: âšª continue, ðŸŸ¡ minor adapt, ðŸŸ  significant adapt, ðŸ”´ stop and re-evaluate
  - [x] Tasks marked `[x]` in tasks file after subagent completion
  - [x] Build progress updated with phase-level summary (not per-task like current)

- [x] **1.1.5** Design the completion section. Phase owner emits `PHASE_COMPLETE` or `BUILD_COMPLETE` with enhanced artifact JSON including `phase_completed`, `completed_phase_tasks`, `remaining_phases`, `phase_task_descriptions`, and `files_touched`. Promise integrity rules preserved
  - **Produces**: Promise tag + enhanced artifact JSON block
  - **Consumed by**: `PromiseCompletion(extract_artifacts=True)` in pipeline; `context.update(result.artifacts)` propagates to code review
  - **Replaces**: Current build.md Step 6 (STOP section â€” enhanced with new artifact fields)
  - [x] JSON block includes `phase_task_descriptions` (full text of completed tasks for code review)
  - [x] JSON block includes `files_touched` (list of all files changed by subagents)
  - [x] Promise tag emitted correctly: PHASE_COMPLETE if more phases, BUILD_COMPLETE if last phase
  - [x] Phase metadata compatible with downstream code review and validate stages

### Phase 2: Pipeline Config & Code Review Updates

#### [x] [2.1] Update pipeline config in create_default_pipeline()
- [x] **2.1.1** Remove the `"TASK_COMPLETE": "build"` transition from the build stage config in `create_default_pipeline()`. Phase owner handles all task iteration internally and only emits PHASE_COMPLETE or BUILD_COMPLETE
  - **Produces**: Updated transitions dict with only `PHASE_COMPLETE â†’ code_review` and `BUILD_COMPLETE â†’ code_review`
  - **Consumed by**: `PipelineExecutor.run()` uses transitions to route between stages
  - **Replaces**: Current TASK_COMPLETE â†’ build loopback (dead code with phase owner)
  - [x] `create_default_pipeline()` build stage transitions: only PHASE_COMPLETE and BUILD_COMPLETE
  - [x] Legacy `create_default_build_validate_pipeline()` left unchanged (backward compat)

- [x] **2.1.2** Adjust `max_iterations` default for the build stage. With phase owner, each iteration covers a full phase (not a single task). Change default from 10 to a lower value (e.g., 5) since builds rarely exceed 5 phases. The `max_build_iterations` parameter still allows override
  - **Produces**: Updated `max_iterations` value in build StageConfig
  - **Consumed by**: `Stage.run()` loop uses max_iterations as safety cap
  - **Replaces**: Current max_iterations=10 (designed for per-task iteration)
  - [x] Default max_iterations set appropriately for phase-level iteration
  - [x] `max_build_iterations` parameter in `create_default_pipeline()` still allows caller override

#### [x] [2.2] Update code review prompt for context isolation
- [x] **2.2.1** Remove full context variable references from `code_review.md`. Replace the Files section that currently references `{tasks_file_path}`, `{progress_file_path}`, and `{additional_context_paths_or_none}` with a reference to `{phase_task_descriptions}` only
  - **Produces**: Updated code_review.md prompt with isolated context
  - **Consumed by**: `Stage.build_prompt()` substitutes variables from context dict
  - **Replaces**: Current Files section with full doc references
  - [x] `{tasks_file_path}`, `{progress_file_path}`, `{additional_context_paths_or_none}` removed from prompt
  - [x] `{phase_task_descriptions}` variable added â€” contains full text of tasks completed in the phase
  - [x] Existing variables preserved: `{changed_files}`, `{commit_messages}`, `{phase_completed}`, `{validated_phases}`, `{review_fixes_path}`

- [x] **2.2.2** Update review scope instructions to reflect the intentional isolation. Code review agent should understand it's reviewing code quality against task descriptions, not broader project scope. Adjust the "Read First" instructions since the agent no longer reads tasks/progress files
  - **Produces**: Updated Instructions section in code_review.md
  - **Consumed by**: Code review agent follows these instructions during review
  - **Replaces**: Current instructions that assume agent reads full project context
  - [x] Instructions direct agent to review code against provided task descriptions
  - [x] "Read First" section updated: reads changed files and task descriptions, not scope docs
  - [x] Review categories, severity scale, and approval threshold unchanged

### Phase 3: Integration Verification

#### [x] [3.1] Verify hooks and artifact propagation
- [x] **3.1.1** Trace the artifact flow from phase owner â†’ code review to verify `phase_task_descriptions` and `files_touched` propagate correctly. The build stage's `PromiseCompletion(extract_artifacts=True)` extracts JSON fields, then `executor.py:275` calls `context.update(result.artifacts)` which makes them available to the code review prompt. Verify no hook changes are needed for this path
  - **Produces**: Confirmed or updated artifact propagation path
  - **Consumed by**: Code review prompt variable substitution
  - **Replaces**: N/A (verification task)
  - [x] `phase_task_descriptions` value available in context when code_review.md template is built
  - [x] `files_touched` value available in context (supplementary to git diff `changed_files`)
  - [x] Git diff hooks (`after_stage_hook`) still capture subagent commits correctly

- [x] **3.1.2** Verify that `after_stage_hook("build")` works correctly when the build stage contains parallel subagent commits. The hook snapshots HEAD before the phase owner starts and collects diff after. Since subagents commit during the phase owner's session, the diff should capture all subagent work
  - **Produces**: Confirmed git hook behavior with parallel subagent commits
  - **Consumed by**: Code review receives `{changed_files}` and `{commit_messages}` from hooks
  - **Replaces**: N/A (verification task)
  - [x] `snapshot_head()` captures correct commit before phase owner starts
  - [x] `collect_diff()` returns all files changed by all subagents in the phase
  - [x] `format_commits()` returns all subagent commit messages

#### [3.2] End-to-end dry run test
- [ ] **3.2.1** Create a small test tasks file with 2 phases, 2-3 tasks each, with wave structure defined. Run a build with the phase owner prompt to verify: phase owner reads context once, dispatches subagents per wave, subagents complete and return reports, phase owner aggregates and emits PHASE_COMPLETE
  - **Produces**: Verified E2E flow with phase owner pattern
  - **Consumed by**: Confidence that the system works before broader use
  - **Replaces**: N/A (verification task)
  - [ ] Phase owner dispatches parallel subagents successfully via Task tool
  - [ ] Subagents complete tasks, commit, and return completion reports
  - [ ] Phase owner emits correct promise tag with enhanced artifact JSON
  - [ ] Code review receives isolated context (task descriptions + git diff only)
  - [ ] Validate stage works unchanged

### Phase 4: Token Tracking (Follow-up)

#### [4.1] Add JSONL-based token tracking for subagent usage
- [ ] **4.1.1** Create a `parse_session_tokens(jsonl_path)` utility in `stats.py` that reads a Claude CLI JSONL transcript, identifies `result` events (including from subagent Task tool dispatches), and aggregates input/output/cache token counts
  - **Produces**: `parse_session_tokens()` function returning aggregated token usage dict
  - **Consumed by**: `BuildStats` integration (4.1.2)
  - **Replaces**: Current stream-only tracking that misses subagent tokens
  - [ ] Parses JSONL format correctly (one JSON object per line)
  - [ ] Identifies `result` events and extracts `usage` fields
  - [ ] Handles nested subagent sessions (Task tool dispatches within a session)
  - [ ] Returns dict with `input_tokens`, `output_tokens`, `cache_read_input_tokens`, `cache_creation_input_tokens`

- [ ] **4.1.2** Integrate JSONL token parsing into `BuildStats`. After each pipeline stage completes, locate the session JSONL file and parse it for accurate totals. Update the dashboard to distinguish between phase owner tokens and subagent tokens
  - **Produces**: Updated `BuildStats` with accurate token counts including subagent usage
  - **Consumed by**: `print_summary()` dashboard display
  - **Replaces**: Current underreporting of subagent tokens
  - [ ] Session JSONL path discoverable from Claude CLI conventions (`~/.claude/projects/{hash}/{session}.jsonl`)
  - [ ] Token counts in dashboard include subagent usage
  - [ ] Cost calculation remains accurate with new token source

---

## Execution Strategies

### Sequential Execution
1. Task 1.1 - Phase owner build prompt rewrite (no dependencies â€” core deliverable)
2. Task 2.1 - Pipeline config update (depends on 1.1 â€” needs to know phase owner signals)
3. Task 2.2 - Code review prompt isolation (depends on 1.1 â€” needs artifact field names)
4. Task 3.1 - Hooks/artifact verification (depends on 1.1, 2.1, 2.2 â€” needs all pieces in place)
5. Task 3.2 - E2E dry run test (depends on 3.1 â€” needs verified system)
6. Task 4.1 - Token tracking from JSONL (independent â€” can be done anytime after 1.1)

### Parallel Execution

**Wave 1**: 1.1
- Phase owner build prompt â€” critical path, all other tasks depend on decisions made here
- Rationale: Must establish the prompt pattern, artifact JSON format, and subagent dispatch approach before downstream tasks can proceed

**Wave 2 (after Wave 1)**: 2.1, 2.2
- Pipeline config + code review isolation â€” both depend on 1.1 but independent of each other
- Rationale: 2.1 removes dead transition; 2.2 updates code review prompt. Neither affects the other. Both need the artifact field names decided in 1.1

**Wave 3 (after Wave 2)**: 3.1, 3.2
- Integration verification + E2E test â€” depend on all prior work being in place
- Rationale: Can't verify artifact flow or run E2E until prompt, pipeline, and code review are all updated. 3.1 (verification) and 3.2 (dry run) can overlap since 3.1 is code inspection and 3.2 is live testing

**Wave 4 (independent)**: 4.1
- Token tracking â€” can be done anytime, no dependencies on Waves 1-3
- Rationale: JSONL parsing is independent infrastructure work. Deferred per scope decision

---

## Coverage Summary
- Total Requirements Extracted: 12
- Requirements with Task Coverage: 12 (100%)
- Phases: 4
- Parent Tasks: 6
- Sub-tasks: 12
