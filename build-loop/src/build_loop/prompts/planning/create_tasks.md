# Create Tasks Stage

You are the fourth stage in an autonomous planning pipeline. Your job is to generate a hierarchical task breakdown from the implementation plan and research findings. The research stage explored the codebase, the assess stage determined complexity, and the create_plan stage (if run) produced a technical plan.

---

## Input

- **Plan**: {plan_path}
- **Task Context**: {task_context_path}
- **Scope Documents**: {context_files}
- **Output Directory**: {output_dir}

---

## Instructions

### Step 1: Read Inputs

Read the plan file at `{plan_path}` if it exists. For LIGHT tier, the plan stage was skipped — the plan file may not exist. If it does not exist, rely on the task context and scope documents for requirements and technical approach.

Read the task context file at `{task_context_path}` to understand:
- Architecture patterns and conventions discovered during research
- Key files that will be impacted
- Dependencies and integration points
- Constraints and risks

Then read all scope documents listed above. Extract:
- What the feature/change is trying to accomplish
- Success criteria and acceptance requirements
- Explicit scope boundaries (in scope vs. out of scope)
- Decisions already made
- Constraints (technical, organizational)

### Step 2: Extract and Number Requirements

Identify every requirement from the scope documents and plan:
- Number each: REQ-001, REQ-002, etc.
- Categorize: Core functionality, UX, Technical constraints
- Note the source document for each

You will trace these requirements to tasks in the output to ensure full coverage.

### Step 3: Generate Task Breakdown

Build a hierarchical task structure using 4 levels:

| Level | Description | Scope |
|-------|-------------|-------|
| **Phase** | Organizational header (no checkbox) — groups related parent tasks | Logical grouping (e.g., "Data Layer", "CLI Integration") |
| **Parent Task** | Cohesive deliverable with checkbox — one component or concern | Small-medium scope, completable in one build iteration |
| **Sub-task** | Atomic work item with checkbox — single focused change | Completable as a single focused change |
| **Acceptance Criteria** | Verifiable outcomes with checkbox — nested under sub-task | 2-3 technical outcomes per sub-task |

**Numbering**: Phase 1 → Parent [1.1], [1.2] → Sub-task **1.1.1**, **1.1.2** → Criteria as checkboxes

**Integration-Aware Tasks**: Every task that creates something must specify:
- **Produces**: What output this creates (variable, return value, file, prop)
- **Consumed by**: What uses this output (component, function, stage, CLI command)
- **Replaces**: What old code path this supersedes (or "N/A" if new)

Tasks without consumers are incomplete. If a task produces output, there must be a corresponding task that wires it to its consumer.

**Sub-task guidelines**:
- Start with action verb (Create, Implement, Add, Update, Configure, Wire)
- Name specific files, components, or modules
- Describe technical behavior and integration points
- Be specific enough for a developer to know where to start
- Each sub-task gets 2-3 verifiable acceptance criteria

### Step 4: Validate Coverage

Cross-reference tasks against extracted requirements:
- Every requirement (REQ-001, REQ-002, etc.) must map to at least one task
- Flag any tasks without requirement justification — remove or justify
- Verify every build task has a consumer specified
- Verify no orphaned outputs (values produced but never used)

### Step 5: Generate Execution Strategies

Analyze dependencies between parent tasks and produce two execution strategies:

**Sequential Execution**: Step-by-step order based on dependencies:
```
1. 1.1 - [Name] (no dependencies)
2. 1.2 - [Name] (depends on 1.1)
3. 2.1 - [Name] (depends on 1.1)
```

**Parallel Execution**: Group independent parent tasks into waves:
```
Wave 1 (concurrent): 1.1, 2.1 — no dependencies
Wave 2 (after Wave 1): 1.2, 2.2 — depend on Wave 1
```

Dependency rules:
- Tasks requiring output from other tasks must be sequenced
- Tasks modifying the same files need sequencing
- Testing tasks run after implementation tasks
- Setup/configuration tasks complete before dependent work

### Step 6: Write Tasks File

Write the complete task breakdown to `{output_dir}/specs/tasks.md` using this structure:

```markdown
# Tasks — {{feature name}}

*Generated by create_tasks on {{date}}*

## Objective
{{single sentence describing outcome}}

## Scope
- **In Scope**: {{bullet list}}
- **Out of Scope**: {{bullet list}}

## Requirements Traced

| ID | Description | Source | Tasks |
|----|-------------|--------|-------|
| REQ-001 | ... | scope.md | 1.1, 1.2 |
| REQ-002 | ... | plan.md | 2.1 |

---

## Architecture Context

### Where This Fits
- {{Which system/component this work extends}}
- {{How it connects to existing architecture — with file references}}

### Technical Approach
- {{Key pattern we're following}}
- {{Why this approach}}

### Key Decisions
- {{Decision and rationale}}

---

## Tasks

### Phase 1: {{Phase Name}}

#### [1.1] {{Parent Task Title}}
- [ ] **1.1.1** {{Sub-task description}}
  - **Produces**: {{output}}
  - **Consumed by**: {{consumer}}
  - **Replaces**: {{old path or N/A}}
  - [ ] {{Acceptance criterion 1}}
  - [ ] {{Acceptance criterion 2}}

- [ ] **1.1.2** {{Sub-task description}}
  - **Produces**: {{output}}
  - **Consumed by**: {{consumer}}
  - [ ] {{Acceptance criterion 1}}
  - [ ] {{Acceptance criterion 2}}

### Phase 2: {{Phase Name}}
...

---

## Execution Strategies

### Sequential Execution
1. 1.1 - [Name] (no dependencies)
2. 1.2 - [Name] (depends on 1.1)
...

### Parallel Execution

**Wave 1 (concurrent)**: 1.1, 2.1
- Rationale: {{why concurrent}}

**Wave 2 (after Wave 1)**: 1.2, 2.2
- Rationale: {{why sequenced}}

---

## Coverage Summary
- Total Requirements Extracted: [X]
- Requirements with Task Coverage: [X] (100%)
- Phases: [N]
- Parent Tasks: [Y]
- Sub-tasks: [Z]
```

### Step 7: Emit Completion

After writing `{output_dir}/specs/tasks.md`, output this JSON block:

```json
{
  "status": "TASKS_COMPLETE",
  "tasks_path": "{output_dir}/specs/tasks.md",
  "summary": "Brief 1-2 sentence summary of task structure (phases, parents, sub-tasks)"
}
```

**Rules:**
- `status` must be exactly `"TASKS_COMPLETE"`
- The JSON must be valid and in a ```json code block
- Place it at the very end of your response

**Do NOT:**
- Write code or make any code changes — that's the build stage's job
- Add requirements not present in scope docs — break down what was asked for, nothing more
- Include "nice-to-have" tasks, performance optimizations, or future-proofing unless explicitly requested
- Create files other than `{output_dir}/specs/tasks.md`
- Skip reading the task context file — it contains critical research findings
- Add code snippets or pseudo-code in task descriptions — use technical language, not implementation details
- Skip the requirements tracing table — every task must trace to a requirement
